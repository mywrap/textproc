package textproc

import (
	"bytes"
	"fmt"
	"net/url"
	"sort"
	"strings"

	"github.com/antchfx/htmlquery"
	"github.com/antchfx/xpath"
	"golang.org/x/net/html"
)

// HTMLXPath finds all html nodes match the xpath query
func HTMLXPath(htmlTree *html.Node, xPath string) ([]*html.Node, error) {
	xPathObj, err := xpath.Compile(xPath)
	if err != nil {
		return nil, fmt.Errorf("error xpath Compile: %v", err)
	}
	nodes := htmlquery.QuerySelectorAll(htmlTree, xPathObj)
	return nodes, nil
}

// HTMLGetText returns all text in the HTML.
// Result does not contain js code or texts that are generated by js.
// This func is slow, caller should reuse the result if possible.
func HTMLGetText(node *html.Node) string {
	excludedTags := map[string]bool{"script": true, "style": true}

	var buf bytes.Buffer
	var f func(*html.Node)
	f = func(n *html.Node) {
		if n.Type == html.TextNode {
			isExcluded := false
			if n.Parent != nil {
				isExcluded = excludedTags[n.Parent.Data]
			}
			if !isExcluded {
				buf.WriteString(n.Data)
				buf.WriteString("\n")
			}
		}
		if n.FirstChild != nil {
			for c := n.FirstChild; c != nil; c = c.NextSibling {
				f(c)
			}
		}
	}

	f(node)
	result := buf.String()
	result = strings.TrimSpace(result)
	result = RemoveRedundantSpace(result)
	result = NormalizeText(result)

	return result
}

// HTMLGetHREFs returns all URLs in the HTML as absolute URLs,
// URLs with different fragments are treated as one URL.
// Silently ignore if baseUrlStr is invalid.
func HTMLGetHREFs(baseUrlStr string, node *html.Node) []string {
	setUrls := make(map[string]bool)
	baseUrl, _ := url.Parse(baseUrlStr)
	elems, _ := HTMLXPath(node, "//a/@href")
	for _, elem := range elems {
		if elem.FirstChild != nil {
			relativeUrlStr := elem.FirstChild.Data
			url0, _ := url.Parse(relativeUrlStr)
			if baseUrl != nil {
				url0 = baseUrl.ResolveReference(url0)
			}
			url0.Fragment = ""
			setUrls[url0.String()] = true
		}
	}

	result := make([]string, 0)
	for k, _ := range setUrls {
		result = append(result, k)
	}
	sort.Strings(result)
	return result
}

// HTMLGetImgSrc returns absolute url of the image
func HTMLGetImgSrc(baseUrlStr string, imgNode *html.Node) string {
	var imgSrcS string
	for _, attr := range imgNode.Attr {
		if attr.Key == "src" {
			imgSrcS = attr.Val
			break
		}
	}

	// convert relative url to absolute url
	baseUrl, _ := url.Parse(baseUrlStr)
	imgSrc, _ := url.Parse(imgSrcS)
	if imgSrc == nil {
		return ""
	}
	if baseUrl != nil {
		imgSrc = baseUrl.ResolveReference(imgSrc)
	}
	if !strings.HasPrefix(imgSrc.String(), "http") {
		return "" // src can be "data:image/jpeg;base64,ddd"
	}
	return imgSrc.String()
}
