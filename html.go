package textproc

import (
	"bytes"
	"encoding/xml"
	"fmt"
	"io"
	"net/url"
	"sort"
	"strings"

	"github.com/antchfx/htmlquery"
	"github.com/antchfx/xpath"
	"golang.org/x/net/html"
)

// HTMLXPath finds all html nodes match the xpath query
func HTMLXPath(htmlTree *html.Node, xPath string) ([]*html.Node, error) {
	xPathObj, err := xpath.Compile(xPath)
	if err != nil {
		return nil, fmt.Errorf("error xpath Compile: %v", err)
	}
	nodes := htmlquery.QuerySelectorAll(htmlTree, xPathObj)
	return nodes, nil
}

// HTMLGetText returns all text in the HTML.
// Result does not contain js code or texts that are generated by js.
// This func is slow, caller should reuse the result if possible.
func HTMLGetText(node *html.Node) string {
	excludedTags := map[string]bool{"script": true, "style": true}

	var buf bytes.Buffer
	var f func(*html.Node)
	f = func(n *html.Node) {
		if n.Type == html.TextNode {
			isExcluded := false
			if n.Parent != nil {
				isExcluded = excludedTags[n.Parent.Data]
			}
			if !isExcluded {
				buf.WriteString(n.Data)
				buf.WriteString("\n")
			}
		}
		if n.FirstChild != nil {
			for c := n.FirstChild; c != nil; c = c.NextSibling {
				f(c)
			}
		}
	}

	f(node)
	result := buf.String()
	result = strings.TrimSpace(result)
	result = RemoveRedundantSpace(result)
	result = NormalizeText(result)

	return result
}

// HTMLGetHREFs returns all URLs in the HTML as absolute URLs,
// URLs with different fragments are treated as one URL.
// Silently ignore if baseUrlStr is invalid.
func HTMLGetHREFs(baseUrlStr string, node *html.Node) []string {
	setUrls := make(map[string]bool)
	baseUrl, _ := url.Parse(baseUrlStr)
	elems, _ := HTMLXPath(node, "//a/@href")
	for _, elem := range elems {
		if elem.FirstChild != nil {
			relativeUrlStr := elem.FirstChild.Data
			url0, _ := url.Parse(relativeUrlStr)
			if baseUrl != nil {
				url0 = baseUrl.ResolveReference(url0)
			}
			url0.Fragment = ""
			setUrls[url0.String()] = true
		}
	}

	result := make([]string, 0)
	for k := range setUrls {
		result = append(result, k)
	}
	sort.Strings(result)
	return result
}

// HTMLGetImgSrc returns absolute url of the image
func HTMLGetImgSrc(baseUrlStr string, imgNode *html.Node) string {
	var imgSrcS string
	for _, attr := range imgNode.Attr {
		if attr.Key == "src" {
			imgSrcS = attr.Val
			break
		}
	}

	// convert relative url to absolute url
	baseUrl, _ := url.Parse(baseUrlStr)
	imgSrc, _ := url.Parse(imgSrcS)
	if imgSrc == nil {
		return ""
	}
	if baseUrl != nil {
		imgSrc = baseUrl.ResolveReference(imgSrc)
	}
	if !strings.HasPrefix(imgSrc.String(), "http") {
		return "" // src can be "data:image/jpeg;base64,ddd"
	}
	return imgSrc.String()
}

// HTMLParseToNode parses a HTML content (string, []byte or io_Reader) into a
// html_Node (returns an empty node on error).
// Should only be used for convenient testing.
func HTMLParseToNode(htmlContent interface{}) *html.Node {
	emptyNode, err := html.Parse(strings.NewReader(
		`<!DOCTYPE html><html><body></body></html>`))
	if err != nil { // unreachable
		emptyNode = &html.Node{}
	}
	var reader io.Reader
	switch v := htmlContent.(type) {
	case string:
		reader = strings.NewReader(v)
	case []byte:
		reader = bytes.NewReader(v)
	case io.Reader:
		reader = v
	}
	node, err := html.Parse(reader)
	if err != nil {
		return emptyNode
	}
	return node
}

// HTMLRender is a convenient func to render a html node to string
func HTMLRender(node *html.Node) string {
	buf := &bytes.Buffer{}
	err := html.Render(buf, node)
	if err != nil {
		return fmt.Sprintf("error html.Render: %v", err)
	}
	return buf.String()
}

// HTMLRenderIndent renders an HTML node to a string with applying indent to format the output.
// Each element in the output will begin on a new line beginning with "prefix"
// followed by one or more copies of "indent" according to the indentation nesting.
func HTMLRenderIndent(node *html.Node, prefix string, indent string) string {
	buf := &bytes.Buffer{}
	err := html.Render(buf, node)
	if err != nil {
		return fmt.Sprintf("error html.Render: %v", err)
	}
	decoder := xml.NewDecoder(buf)

	ret := &bytes.Buffer{}
	encoder := xml.NewEncoder(ret)
	encoder.Indent(prefix, indent)
	for {
		token, err := decoder.Token()
		if err == io.EOF {
			encoder.Flush()
			return ret.String()
		}
		if err != nil {
			return fmt.Sprintf("error decoder.Token: %v", err)
		}
		err = encoder.EncodeToken(token)
		if err != nil {
			return fmt.Sprintf("error encoder.EncodeToken: %v", err)
		}
	}
}

// CheckValidXPath returns nil if the input xPath is valid
func CheckValidXPath(xPath string) error {
	_, err := xpath.Compile(xPath)
	if err != nil {
		return err
	}
	return nil
}
